---
title: "TrainClassifier"
output: html_document
---

```{r setup, include=FALSE}
for(p in c("caret","devtools","xts", "dimRed", "foreach","tidyr","fastICA", "e1071"))
if (!require(p,character.only=TRUE)) {
    install.packages(p)
    require(p,character.only=TRUE)
}

if (!require("influxdbr2",character.only=TRUE)) {
devtools::install_github("mvadu/influxdbr2")
  require("influxdbr2",character.only=TRUE)
}
```


# Database connection

```{r cars}
con <- influx_connection(host = "css20.dmz.teco.edu", scheme="http", port=80) 
result=influx_query_xts(con,db="browser", "select * FROM devicemotion GROUP BY label, subject")
```

# Transform data to table

```{r}
xts_as_table <- function(xts_file){
  # loop over every element of xts_file
  res <- foreach(i=1:length(result),.combine = rbind) %do% {
      # apply split to do windowing: split by seconds
      foreach(s=split(result[i][[1]]$values,"second",k=2),.combine = rbind) %do% {
          # intitialize r
          r={}
          # add subject and label
          r$subject=result[i][[1]]$tags$subject 
          r$label=result[i][[1]]$tags$label
          # extract acceleration coordinates x,y,z
          x=as.numeric(s$accelerationIncludingGravity.x)
          y=as.numeric(s$accelerationIncludingGravity.x)
          z=as.numeric(s$accelerationIncludingGravity.z)
          
          # calculate rmse from x,y,z
          three_d=apply(cbind(x,y,z),FUN=function(x) sqrt(sum(x^2)),MARGIN=1)
          
          # add mobile
          r$mobile=as.vector(first(s$mobile)) 
          # calculate means and add them
          r$mean_x=mean(x,na.rm = TRUE)
          r$mean_y=mean(y,na.rm = TRUE)
          r$mean_z=mean(z,na.rm = TRUE)
          r$mean_3d=mean(three_d,na.rm = TRUE)
          
          # calclate variances and add them
          r$var_x=var(x, na.rm = TRUE)
          r$var_y=var(y,na.rm = TRUE)
          r$var_z=var(z, na.rm = TRUE)
          r$var_3d=var(three_d, na.rm = TRUE)
          
          # calculate ranges and add them
          r$minmax_x=max(x,na.rm = TRUE)-min(x,na.rm = TRUE)
          r$minmax_y=max(y,na.rm = TRUE)-min(y,na.rm = TRUE)
          r$minmax_z=max(z,na.rm = TRUE)-min(z,na.rm = TRUE)
          r$minmax_3d=max(three_d,na.rm = TRUE)-min(three_d,na.rm = TRUE)
          
          # return as df to rbind
          as.data.frame(r)
        }
  }
  return(as.data.frame(res))
}

data <- xts_as_table(result)
```

# Data Cleansing

```{r}
# remove testing
data <- dplyr::filter(data, label!="testing")
```

```{r}
# The function IQR.outliers detects outliers
IQR.outliers <- function(data) {
  Q3<-quantile(data,0.75)
  Q1<-quantile(data,0.25)
  IQR<-(Q3-Q1)
  left<- Q1-(1.5*IQR)
  right<- Q3+(1.5*IQR)
  print(sum(data < left))
  print(sum(data > right))
  index <- data < left | data>right
  return(which(index))
}
```




```{r}
# create new frame to visualize remaining NA values
data_NA <- data[rowSums(is.na(data)) > 0,]
data<-drop_na(data)

# show dropped NA-Values
data_NA
```


